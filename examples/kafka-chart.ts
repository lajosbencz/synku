import { IComponent, helm } from '../src';

export interface KafkaChartValues {
  global?: {
    imageRegistry?: string;
    imagePullSecrets?: any[];
    defaultStorageClass?: string;
    security?: {
    allowInsecureImages?: boolean;
  };
    compatibility?: {
    openshift?: {
    adaptSecurityContext?: string;
  };
  };
  };
  kubeVersion?: string;
  apiVersions?: any[];
  nameOverride?: string;
  fullnameOverride?: string;
  namespaceOverride?: string;
  clusterDomain?: string;
  commonLabels?: {

  };
  commonAnnotations?: {

  };
  extraDeploy?: any[];
  usePasswordFiles?: boolean;
  diagnosticMode?: {
    enabled?: boolean;
    command?: string[];
    args?: string[];
  };
  serviceBindings?: {
    enabled?: boolean;
  };
  image?: {
    registry?: string;
    repository?: string;
    tag?: string;
    digest?: string;
    pullPolicy?: string;
    pullSecrets?: any[];
    debug?: boolean;
  };
  clusterId?: string;
  existingKraftSecret?: string;
  kraftVersion?: number;
  config?: {

  };
  overrideConfiguration?: {

  };
  existingConfigmap?: string;
  secretConfig?: string;
  existingSecretConfig?: string;
  log4j2?: string;
  existingLog4j2ConfigMap?: string;
  heapOpts?: string;
  brokerRackAwareness?: {
    enabled?: boolean;
    cloudProvider?: string;
    azureApiVersion?: string;
  };
  interBrokerProtocolVersion?: string;
  listeners?: {
    client?: {
    containerPort?: number;
    protocol?: string;
    name?: string;
    sslClientAuth?: string;
  };
    controller?: {
    name?: string;
    containerPort?: number;
    protocol?: string;
    sslClientAuth?: string;
  };
    interbroker?: {
    containerPort?: number;
    protocol?: string;
    name?: string;
    sslClientAuth?: string;
  };
    external?: {
    containerPort?: number;
    protocol?: string;
    name?: string;
    sslClientAuth?: string;
  };
    extraListeners?: any[];
    overrideListeners?: string;
    advertisedListeners?: string;
    securityProtocolMap?: string;
  };
  sasl?: {
    enabledMechanisms?: string;
    interBrokerMechanism?: string;
    controllerMechanism?: string;
    oauthbearer?: {
    tokenEndpointUrl?: string;
    jwksEndpointUrl?: string;
    expectedAudience?: string;
    subClaimName?: string;
  };
    interbroker?: {
    user?: string;
    password?: string;
    clientId?: string;
    clientSecret?: string;
  };
    controller?: {
    user?: string;
    password?: string;
    clientId?: string;
    clientSecret?: string;
  };
    client?: {
    users?: string[];
    passwords?: string;
  };
    existingSecret?: string;
  };
  tls?: {
    type?: string;
    pemChainIncluded?: boolean;
    autoGenerated?: {
    enabled?: boolean;
    engine?: string;
    customAltNames?: any[];
    certManager?: {
    existingIssuer?: string;
    existingIssuerKind?: string;
    keySize?: number;
    keyAlgorithm?: string;
    duration?: string;
    renewBefore?: string;
  };
  };
    existingSecret?: string;
    passwordsSecret?: string;
    passwordsSecretKeystoreKey?: string;
    passwordsSecretTruststoreKey?: string;
    passwordsSecretPemPasswordKey?: string;
    keystorePassword?: string;
    truststorePassword?: string;
    keyPassword?: string;
    jksKeystoreKey?: string;
    jksTruststoreSecret?: string;
    jksTruststoreKey?: string;
    endpointIdentificationAlgorithm?: string;
    sslClientAuth?: string;
  };
  extraEnvVars?: any[];
  extraEnvVarsCM?: string;
  extraEnvVarsSecret?: string;
  extraVolumes?: any[];
  extraVolumeMounts?: any[];
  sidecars?: any[];
  initContainers?: any[];
  dnsPolicy?: string;
  dnsConfig?: {

  };
  defaultInitContainers?: {
    volumePermissions?: {
    enabled?: boolean;
    image?: {
    registry?: string;
    repository?: string;
    tag?: string;
    digest?: string;
    pullPolicy?: string;
    pullSecrets?: any[];
  };
    containerSecurityContext?: {
    enabled?: boolean;
    seLinuxOptions?: {

  };
    runAsUser?: number;
    privileged?: boolean;
    allowPrivilegeEscalation?: boolean;
    capabilities?: {
    add?: any[];
    drop?: string[];
  };
    seccompProfile?: {
    type?: string;
  };
  };
    resourcesPreset?: string;
    resources?: {

  };
  };
    prepareConfig?: {
    containerSecurityContext?: {
    enabled?: boolean;
    seLinuxOptions?: {

  };
    runAsUser?: number;
    runAsGroup?: number;
    runAsNonRoot?: boolean;
    readOnlyRootFilesystem?: boolean;
    privileged?: boolean;
    allowPrivilegeEscalation?: boolean;
    capabilities?: {
    add?: any[];
    drop?: string[];
  };
    seccompProfile?: {
    type?: string;
  };
  };
    resourcesPreset?: string;
    resources?: {

  };
    extraInit?: string;
  };
    autoDiscovery?: {
    enabled?: boolean;
    image?: {
    registry?: string;
    repository?: string;
    tag?: string;
    digest?: string;
    pullPolicy?: string;
    pullSecrets?: any[];
  };
    containerSecurityContext?: {
    enabled?: boolean;
    seLinuxOptions?: {

  };
    runAsUser?: number;
    runAsGroup?: number;
    runAsNonRoot?: boolean;
    readOnlyRootFilesystem?: boolean;
    privileged?: boolean;
    allowPrivilegeEscalation?: boolean;
    capabilities?: {
    add?: any[];
    drop?: string[];
  };
    seccompProfile?: {
    type?: string;
  };
  };
    resourcesPreset?: string;
    resources?: {

  };
  };
  };
  controller?: {
    replicaCount?: number;
    controllerOnly?: boolean;
    quorumBootstrapServers?: string;
    minId?: number;
    config?: {

  };
    overrideConfiguration?: {

  };
    existingConfigmap?: string;
    secretConfig?: string;
    existingSecretConfig?: string;
    heapOpts?: string;
    command?: any[];
    args?: any[];
    extraEnvVars?: any[];
    extraEnvVarsCM?: string;
    extraEnvVarsSecret?: string;
    extraContainerPorts?: any[];
    livenessProbe?: {
    enabled?: boolean;
    initialDelaySeconds?: number;
    timeoutSeconds?: number;
    failureThreshold?: number;
    periodSeconds?: number;
    successThreshold?: number;
  };
    readinessProbe?: {
    enabled?: boolean;
    initialDelaySeconds?: number;
    failureThreshold?: number;
    timeoutSeconds?: number;
    periodSeconds?: number;
    successThreshold?: number;
  };
    startupProbe?: {
    enabled?: boolean;
    initialDelaySeconds?: number;
    periodSeconds?: number;
    timeoutSeconds?: number;
    failureThreshold?: number;
    successThreshold?: number;
  };
    customLivenessProbe?: {

  };
    customReadinessProbe?: {

  };
    customStartupProbe?: {

  };
    lifecycleHooks?: {

  };
    resourcesPreset?: string;
    resources?: {

  };
    podSecurityContext?: {
    enabled?: boolean;
    fsGroupChangePolicy?: string;
    sysctls?: any[];
    supplementalGroups?: any[];
    fsGroup?: number;
    seccompProfile?: {
    type?: string;
  };
  };
    containerSecurityContext?: {
    enabled?: boolean;
    seLinuxOptions?: {

  };
    runAsUser?: number;
    runAsGroup?: number;
    runAsNonRoot?: boolean;
    allowPrivilegeEscalation?: boolean;
    readOnlyRootFilesystem?: boolean;
    capabilities?: {
    drop?: string[];
  };
  };
    automountServiceAccountToken?: boolean;
    hostAliases?: any[];
    hostNetwork?: boolean;
    hostIPC?: boolean;
    podLabels?: {

  };
    podAnnotations?: {

  };
    topologyKey?: string;
    podAffinityPreset?: string;
    podAntiAffinityPreset?: string;
    nodeAffinityPreset?: {
    type?: string;
    key?: string;
    values?: any[];
  };
    affinity?: {

  };
    nodeSelector?: {

  };
    tolerations?: any[];
    topologySpreadConstraints?: any[];
    terminationGracePeriodSeconds?: string;
    podManagementPolicy?: string;
    minReadySeconds?: number;
    priorityClassName?: string;
    runtimeClassName?: string;
    enableServiceLinks?: boolean;
    schedulerName?: string;
    updateStrategy?: {
    type?: string;
  };
    extraVolumes?: any[];
    extraVolumeMounts?: any[];
    sidecars?: any[];
    initContainers?: any[];
    autoscaling?: {
    vpa?: {
    enabled?: boolean;
    annotations?: {

  };
    controlledResources?: any[];
    maxAllowed?: {

  };
    minAllowed?: {

  };
    updatePolicy?: {
    updateMode?: string;
  };
  };
    hpa?: {
    enabled?: boolean;
    annotations?: {

  };
    minReplicas?: string;
    maxReplicas?: string;
    targetCPU?: string;
    targetMemory?: string;
  };
  };
    pdb?: {
    create?: boolean;
    minAvailable?: string;
    maxUnavailable?: string;
  };
    persistentVolumeClaimRetentionPolicy?: {
    enabled?: boolean;
    whenScaled?: string;
    whenDeleted?: string;
  };
    persistence?: {
    enabled?: boolean;
    existingClaim?: string;
    storageClass?: string;
    accessModes?: string[];
    size?: string;
    annotations?: {

  };
    labels?: {

  };
    selector?: {

  };
    mountPath?: string;
  };
    logPersistence?: {
    enabled?: boolean;
    existingClaim?: string;
    storageClass?: string;
    accessModes?: string[];
    size?: string;
    annotations?: {

  };
    selector?: {

  };
    mountPath?: string;
  };
  };
  broker?: {
    replicaCount?: number;
    minId?: number;
    config?: {

  };
    overrideConfiguration?: {

  };
    existingConfigmap?: string;
    secretConfig?: string;
    existingSecretConfig?: string;
    heapOpts?: string;
    command?: any[];
    args?: any[];
    extraEnvVars?: any[];
    extraEnvVarsCM?: string;
    extraEnvVarsSecret?: string;
    extraContainerPorts?: any[];
    livenessProbe?: {
    enabled?: boolean;
    initialDelaySeconds?: number;
    timeoutSeconds?: number;
    failureThreshold?: number;
    periodSeconds?: number;
    successThreshold?: number;
  };
    readinessProbe?: {
    enabled?: boolean;
    initialDelaySeconds?: number;
    failureThreshold?: number;
    timeoutSeconds?: number;
    periodSeconds?: number;
    successThreshold?: number;
  };
    startupProbe?: {
    enabled?: boolean;
    initialDelaySeconds?: number;
    periodSeconds?: number;
    timeoutSeconds?: number;
    failureThreshold?: number;
    successThreshold?: number;
  };
    customLivenessProbe?: {

  };
    customReadinessProbe?: {

  };
    customStartupProbe?: {

  };
    lifecycleHooks?: {

  };
    resourcesPreset?: string;
    resources?: {

  };
    podSecurityContext?: {
    enabled?: boolean;
    fsGroupChangePolicy?: string;
    sysctls?: any[];
    supplementalGroups?: any[];
    fsGroup?: number;
    seccompProfile?: {
    type?: string;
  };
  };
    containerSecurityContext?: {
    enabled?: boolean;
    seLinuxOptions?: {

  };
    runAsUser?: number;
    runAsGroup?: number;
    runAsNonRoot?: boolean;
    allowPrivilegeEscalation?: boolean;
    readOnlyRootFilesystem?: boolean;
    capabilities?: {
    drop?: string[];
  };
  };
    automountServiceAccountToken?: boolean;
    hostAliases?: any[];
    hostNetwork?: boolean;
    hostIPC?: boolean;
    podLabels?: {

  };
    podAnnotations?: {

  };
    topologyKey?: string;
    podAffinityPreset?: string;
    podAntiAffinityPreset?: string;
    nodeAffinityPreset?: {
    type?: string;
    key?: string;
    values?: any[];
  };
    affinity?: {

  };
    nodeSelector?: {

  };
    tolerations?: any[];
    topologySpreadConstraints?: any[];
    terminationGracePeriodSeconds?: string;
    podManagementPolicy?: string;
    minReadySeconds?: number;
    priorityClassName?: string;
    runtimeClassName?: string;
    enableServiceLinks?: boolean;
    schedulerName?: string;
    updateStrategy?: {
    type?: string;
  };
    extraVolumes?: any[];
    extraVolumeMounts?: any[];
    sidecars?: any[];
    initContainers?: any[];
    pdb?: {
    create?: boolean;
    minAvailable?: string;
    maxUnavailable?: string;
  };
    autoscaling?: {
    vpa?: {
    enabled?: boolean;
    annotations?: {

  };
    controlledResources?: any[];
    maxAllowed?: {

  };
    minAllowed?: {

  };
    updatePolicy?: {
    updateMode?: string;
  };
  };
    hpa?: {
    enabled?: boolean;
    annotations?: {

  };
    minReplicas?: string;
    maxReplicas?: string;
    targetCPU?: string;
    targetMemory?: string;
  };
  };
    persistentVolumeClaimRetentionPolicy?: {
    enabled?: boolean;
    whenScaled?: string;
    whenDeleted?: string;
  };
    persistence?: {
    enabled?: boolean;
    existingClaim?: string;
    storageClass?: string;
    accessModes?: string[];
    size?: string;
    annotations?: {

  };
    labels?: {

  };
    selector?: {

  };
    mountPath?: string;
  };
    logPersistence?: {
    enabled?: boolean;
    existingClaim?: string;
    storageClass?: string;
    accessModes?: string[];
    size?: string;
    annotations?: {

  };
    selector?: {

  };
    mountPath?: string;
  };
  };
  service?: {
    type?: string;
    ports?: {
    client?: number;
    controller?: number;
    interbroker?: number;
    external?: number;
  };
    extraPorts?: any[];
    nodePorts?: {
    client?: string;
    external?: string;
  };
    sessionAffinity?: string;
    sessionAffinityConfig?: {

  };
    clusterIP?: string;
    loadBalancerIP?: string;
    loadBalancerClass?: string;
    loadBalancerSourceRanges?: any[];
    allocateLoadBalancerNodePorts?: boolean;
    externalTrafficPolicy?: string;
    annotations?: {

  };
    headless?: {
    controller?: {
    annotations?: {

  };
    labels?: {

  };
  };
    broker?: {
    annotations?: {

  };
    labels?: {

  };
  };
    ipFamilies?: any[];
    ipFamilyPolicy?: string;
  };
  };
  externalAccess?: {
    enabled?: boolean;
    controller?: {
    forceExpose?: boolean;
    service?: {
    type?: string;
    ports?: {
    external?: number;
  };
    loadBalancerClass?: string;
    loadBalancerIPs?: any[];
    loadBalancerNames?: any[];
    loadBalancerAnnotations?: any[];
    loadBalancerSourceRanges?: any[];
    allocateLoadBalancerNodePorts?: boolean;
    nodePorts?: any[];
    externalIPs?: any[];
    useHostIPs?: boolean;
    usePodIPs?: boolean;
    domain?: string;
    publishNotReadyAddresses?: boolean;
    labels?: {

  };
    annotations?: {

  };
    extraPorts?: any[];
    ipFamilies?: any[];
    ipFamilyPolicy?: string;
  };
  };
    broker?: {
    service?: {
    type?: string;
    ports?: {
    external?: number;
  };
    loadBalancerClass?: string;
    loadBalancerIPs?: any[];
    loadBalancerNames?: any[];
    loadBalancerAnnotations?: any[];
    loadBalancerSourceRanges?: any[];
    allocateLoadBalancerNodePorts?: boolean;
    nodePorts?: any[];
    externalIPs?: any[];
    useHostIPs?: boolean;
    usePodIPs?: boolean;
    domain?: string;
    publishNotReadyAddresses?: boolean;
    labels?: {

  };
    annotations?: {

  };
    extraPorts?: any[];
    ipFamilies?: any[];
    ipFamilyPolicy?: string;
  };
  };
  };
  networkPolicy?: {
    enabled?: boolean;
    allowExternal?: boolean;
    allowExternalEgress?: boolean;
    addExternalClientAccess?: boolean;
    extraIngress?: any[];
    extraEgress?: any[];
    ingressPodMatchLabels?: {

  };
    ingressNSMatchLabels?: {

  };
    ingressNSPodMatchLabels?: {

  };
  };
  serviceAccount?: {
    create?: boolean;
    name?: string;
    automountServiceAccountToken?: boolean;
    annotations?: {

  };
  };
  rbac?: {
    create?: boolean;
  };
  metrics?: {
    jmx?: {
    enabled?: boolean;
    kafkaJmxPort?: number;
    image?: {
    registry?: string;
    repository?: string;
    tag?: string;
    digest?: string;
    pullPolicy?: string;
    pullSecrets?: any[];
  };
    containerSecurityContext?: {
    enabled?: boolean;
    seLinuxOptions?: {

  };
    runAsUser?: number;
    runAsGroup?: number;
    runAsNonRoot?: boolean;
    allowPrivilegeEscalation?: boolean;
    readOnlyRootFilesystem?: boolean;
    capabilities?: {
    drop?: string[];
  };
  };
    containerPorts?: {
    metrics?: number;
  };
    resourcesPreset?: string;
    resources?: {

  };
    livenessProbe?: {
    enabled?: boolean;
    initialDelaySeconds?: number;
    periodSeconds?: number;
    timeoutSeconds?: number;
    successThreshold?: number;
    failureThreshold?: number;
  };
    readinessProbe?: {
    enabled?: boolean;
    initialDelaySeconds?: number;
    periodSeconds?: number;
    timeoutSeconds?: number;
    successThreshold?: number;
    failureThreshold?: number;
  };
    service?: {
    ports?: {
    metrics?: number;
  };
    clusterIP?: string;
    sessionAffinity?: string;
    annotations?: {
    "prometheus.io/scrape"?: string;
    "prometheus.io/port"?: string;
    "prometheus.io/path"?: string;
  };
    ipFamilies?: any[];
    ipFamilyPolicy?: string;
  };
    whitelistObjectNames?: string[];
    config?: string;
    existingConfigmap?: string;
    extraRules?: string;
  };
    serviceMonitor?: {
    enabled?: boolean;
    namespace?: string;
    path?: string;
    interval?: string;
    scrapeTimeout?: string;
    labels?: {

  };
    selector?: {

  };
    relabelings?: any[];
    metricRelabelings?: any[];
    honorLabels?: boolean;
    jobLabel?: string;
  };
    prometheusRule?: {
    enabled?: boolean;
    namespace?: string;
    labels?: {

  };
    groups?: any[];
  };
  };
  provisioning?: {
    enabled?: boolean;
    waitForKafka?: boolean;
    useHelmHooks?: boolean;
    automountServiceAccountToken?: boolean;
    numPartitions?: number;
    replicationFactor?: number;
    topics?: any[];
    nodeSelector?: {

  };
    tolerations?: any[];
    extraProvisioningCommands?: any[];
    parallel?: number;
    preScript?: string;
    postScript?: string;
    auth?: {
    tls?: {
    type?: string;
    certificatesSecret?: string;
    cert?: string;
    key?: string;
    caCert?: string;
    keystore?: string;
    truststore?: string;
    passwordsSecret?: string;
    keyPasswordSecretKey?: string;
    keystorePasswordSecretKey?: string;
    truststorePasswordSecretKey?: string;
    keyPassword?: string;
    keystorePassword?: string;
    truststorePassword?: string;
  };
  };
    command?: any[];
    args?: any[];
    extraEnvVars?: any[];
    extraEnvVarsCM?: string;
    extraEnvVarsSecret?: string;
    podAnnotations?: {

  };
    podLabels?: {

  };
    serviceAccount?: {
    create?: boolean;
    name?: string;
    automountServiceAccountToken?: boolean;
  };
    resourcesPreset?: string;
    resources?: {

  };
    podSecurityContext?: {
    enabled?: boolean;
    fsGroupChangePolicy?: string;
    sysctls?: any[];
    supplementalGroups?: any[];
    fsGroup?: number;
    seccompProfile?: {
    type?: string;
  };
  };
    containerSecurityContext?: {
    enabled?: boolean;
    seLinuxOptions?: {

  };
    runAsUser?: number;
    runAsGroup?: number;
    runAsNonRoot?: boolean;
    allowPrivilegeEscalation?: boolean;
    readOnlyRootFilesystem?: boolean;
    capabilities?: {
    drop?: string[];
  };
  };
    schedulerName?: string;
    enableServiceLinks?: boolean;
    extraVolumes?: any[];
    extraVolumeMounts?: any[];
    sidecars?: any[];
    initContainers?: any[];
  };
}

/**
 * KafkaChart - Helm chart wrapper
 * Apache Kafka is a distributed streaming platform designed to build real-time pipelines and can be used as a message broker or as a replacement for a log aggregation solution for big data applications.
 * @version 32.3.14
 * @see https://bitnami.com
 * @source oci://registry-1.docker.io/bitnamicharts/kafka
 */
export class KafkaChart extends helm.Chart<KafkaChartValues> {
  constructor(values: KafkaChartValues, name?: string, parent?: IComponent, namespace?: string) {
    super('oci://registry-1.docker.io/bitnamicharts/kafka', values, name || 'kafka', parent, namespace);
  }
}
